<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>index</title>
    <style>
        .context p {
            text-align: justify;
            text-justify: inter-ideograph;
            text-indent: 2em;
        }
    </style>
</head>
<body>
<div class="context">
    <h3>array</h3>
    <p>
        数组(Array)大概是最简单，也是最常用的数据结构了。其他数据结构，比如栈和队列都是由数组衍生出来的。
        每一个数组元素的位置由数字编号，称为下标或者索引(index)。大多数编程语言的数组第一个元素的下标是 0
        根据维度区分，有 2 种不同的数组：
        多维数组(数组的元素为数组)
    </p>
</div>
<div class="context">
    <h3>graph</h3>
    <p>
        图(GRAPH)的定义：是一种非线性数据结构，由有穷、非空的点集V(G)和边集E(G)组成。当G中的每条边有方向时，称G为有向图，有向边（用一对尖括号<a,b>）又称为弧，起始顶点被称为弧尾，终止顶点被称为弧头，每条边无方向时（用一对括号表示（a,b）和（b,a）一样），被称为无向图。

    </p>
    <p> 图中顶点和边的关系：

    </p>
    <p> 有向图：顶点n和边数e，满足0<=e<=n(n-1)，若e = n(n-1)，称为完全有向图：每个顶点之间都有两条互为相反的边的无向图；
    </p>
    <p> 无向图：顶点n和边数e，满足0<=e<=n(n-1)/2，若e = n(n-1)/2，称为完全无向图：每个顶点之间都有一条边的无向图；
    </p>
    <p> 若图中e < n lbn 称该图为稀疏图，否则为稠密图；

    </p>
    <p> 图的存储方式：由于图的结构较为复杂，任意两个顶点之间都可能存在联系，因此无法用数据元素在存储区中的物理位置来表示元素之间的关系，但是我们可以借助一个二维数组中的各单元的数据取值或者多重链表来表示元素之间的关系
    </p>
    <p>邻接矩阵
    </p>
    <p>
        使用一个矩阵来表示各顶点之间的关系，A[i,j] = {0或1}，表示顶点i到顶点j的连通性，有向图时为其权值，这样我们就可以使用一个二维数组加以表示
        对于网络，邻接矩阵中，直接相邻两点为有权值Wij，与自身关系为0，不直接相连的两点为无穷大：
    </p>
    <p>
        度的概念：
        度：与特定顶点Vi相连接的边数D(Vi)
        出度、入度：对于有向图的概念，出度表示此顶点为起点的边的数目OD(Vi)，入度表示此顶点为终点的边的数目ID(Vi)；对于有向图，顶点的度是入度与出度之和；
        权的概念：在一个图中，如果图的边具有一个与它相关的数，这个数就被称为该边的权，如果图中的每条边都具有权，这个带权图就被称为网络，简称网
        路径概念：从一个顶点到另一定点的次序，被称为路径，对于无权图，沿路径所经过的边数被称为该路径的长度；对于有权图（网络），取沿路径各边的权之和作为此路径的长度；若路径中的顶点不重复出现，该路径为简单路径；起点和终点相同且长度不小于2的简单路径被称为简单回路或者简单环；
    </p>
    <p>
        关于图的连通性：
        对于有向图，若存在一个顶点V，从该顶点有路径达到该图中其他的所有顶点时，称该有向图为有根图，V称为该图的根。若有向图中，不相同顶点V到U和U到V都存在路径，称V和U是强连通的，若图中任意两个顶点都是强连通的，成该图为强连通图；
        对于无向图，若两个顶点V和顶点U有路径相通，则称V和U是连通的。若图中任意两个顶点都连通，则称G为连通图，否则为非连通图。无向图的连通分量就是其自身，非连通图有多个连通分量；
        生成树：
        图论中，树是一个无回路存在的连通图，而一个连通图G的生成图为：一个包含了G所有顶点的树，n个顶点，n-1条边，并且保证n个顶点相互连通（不存在环）；
        最小生成树：
        当使用一个连通网罗来构造生成树时，可以得到一个带权的生成树，把生成树各边的权值总和作为生成树的权，具有最小权值的生成树构成连通网络的最小生成树，构造最小生成树的两种常用算法：Prim算法和Kruskal算法；
        最小生成树的MST性质：假设G=(V,G)是一个连通网络，U是V的一个真子集，若存在顶点u属于U和顶点v属于V-U的边（u,v）是一条具有最小权值的边，则必存在G的一颗最小生成树包括这条边（u,v）
        图的遍历：使用辅助数组 visit[N] 表示顶点是否被遍历过，若已经被访问置1，未被访问置0
        DFS：深度优先搜索：
    </p>
    <p>

        从图中某一顶点出发，访问后标记visit[i]为1，然后依次搜索第i个结点的领接点j，再依次搜索j结点的每个领接点，直到所有结点都被遍历
        BFS：广度优先搜索
        先被访问的结点，其领接点也先被访问，有先进先出的特性，我们使用队列来保存已经访问过的结点，以确定被访问过结点的顶点领接点访问次序。
        生成树与最小生成
        树是一个无回路存在的连通图，而一个连通图G的生成树是指：一个包含了G的所有顶点的树。对于一个有n个顶点的连通图G，其生成树包含了n-1条边，从而生成树是G的一个极小连通的子图。使用DFS遍历搜索得到的树为DFS树，使用BFS遍历搜索得到的树为BFS树。
        因为搜索算法选取的起始顶点不同，所以一个连通图的生成树不是唯一的，它取决于遍历方法和起始顶点的选择。
        对于带权值的连通图，我们可以得到一个带权的生成树，我们将该生成树的各边的权值作为生成树的权，具有最小权值的生成树构成了连通网络的最小生成树
        常用的最小生成树的算法有Prim算法和Krusal算法
        最短路径问题：沿路径的各边权值之和最小。主要有两种算法：
        Dijkstra算法：单源最短路径：求图中某个顶点到其他各顶点的最短路径
        Floyd算法：各顶点间最短路径：每对顶点之间的最短路径
    </p>
</div>
<div class="context">
    <h3>LinearTable</h3>
    <p>
        线性表的定义：线性表是具有相同数据类型的n个数据元素的有限序列。n为表长，当n = 0时，为空表。

        线性表公式表示：L = （a1,a2,a3.......an）, a1 为表头元素，an为表尾元素。除了第一个元素，每个元素都有且仅有一个直接前驱，除了最后一个元素，每个元素有且仅有一个直接后继。


    </p>
    <p>
        线性表的特点：有限个数；逻辑上有顺序性；每个表元素都是单个元素；表元素类型皆相同；元素具有抽象性

        线性表与链表/顺序表之间的区别：线性表是一种逻辑结构，表示元素之间一一对应的关系；链表和顺序表指的是存储结构。

        在计算机内，可以用不同的方式来表示线性表，最简单最常用的方式是顺序存储结构—顺序表，而链表则经常被用来表示非线性的数据结构，也是一种常用的表示线性表的方法。

    </p>
    <p>
        顺序表：线性表的顺序存储被称为顺序表，它是一组地址连续的顺序存储单元，依次存储线性表中的数据元素。注意顺序存储是一种读写方式，不是存储方式，有别于顺序存储。线性表支持随机存取的顺序存储结构

        顺序表的优点：1：存储密度高；2：元素可以随机读取；3：存储位置可以简单的使用公式来表示
    </p>
</div>
<div class="context">

    <h3>linkedlist</h3>
    <p>
        链表(Linked List)也是线性结构，它与数组看起来非常像，但是它们的内存分配方式、内部结构和插入删除操作方式都不一样。
    </p>
    <p>
        链表是一系列节点组成的链，每一个节点保存了数据以及指向下一个节点的指针。链表头指针指向第一个节点，如果链表为空，则头指针为空或者为 null。
    </p>
    <p>
        链表可以用来实现文件系统、哈希表和邻接表。
    </p>
    <p>
        链表分为 2 种：
    </p>
    <p>
        单向链表
    </p>
    <p>
        双向链表
    </p>
    <p>Time Complexity:</p>
    <p> Indexing: Linked Lists: O(n)</p>
    <p>Search: Linked Lists: O(n)</p>
    <p> Optimized Search: Linked Lists: O(n)</p>
    <p>Insertion: Linked Lists: O(1)</p>
</div>
<div class="context">
    <h3>queue</h3>
    <p>
        队列(Queue)与栈类似，都是采用线性结构存储数据.
        它们的区别在于，栈采用 LIFO 方式，而队列采用先进先出，即FIFO(First in First Out)。
    </p>
</div>
<div class="context">
    <h3>stack</h3>
    <p>
        撤回，即 Ctrl+Z，是我们最常见的操作之一，大多数应用都会支持这个功能。
        你知道它是怎么实现的吗？
        答案是这样的：把之前的应用状态(限制个数)保存到内存中，最近的状态放到第一个。
        这时，我们需要栈(stack)来实现这个功能。
        栈中的元素采用 LIFO (Last In First Out)，即后进先出。
    </p>
</div>
<div class="context">
    <h3>tree</h3>
    <p>
        数据结构——树

        定义：树是一个n(n>=0)个结点的有序合集

        名词理解：
        结点：指树中的一个元素；
        结点的度：指结点拥有的子树的个数，二叉树的度不大于2；
        数的度：指树中的最大结点度数；
        叶子：度为0的结点，也称为终端结点；
        高度：叶子节点的高度为1，根节点高度最高；
        层：根在第一层，以此类推；

    </p>
    <p>
        二叉树的定义：由一个结点和两颗互不相交、分别称为这个根的左子树和右子树的二叉树构成（递归定义）
    </p>
    <p>
        二叉树的性质：
        1：二叉树的第i层上至多有2^(i-1)个结点
        2：深度为k的二叉树，至多有2^k-1个结点

        满二叉树：叶子节点一定要在最后一层，并且所有非叶子节点都存在左孩子和右孩子；
        最特别的二叉树：完全二叉树：从左到右、从上到下构建的二叉树；
    </p>
</div>

</body>
</html>